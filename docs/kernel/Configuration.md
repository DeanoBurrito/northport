# Kernel Config
It's named 'Configuration' to avoid confusion as config gets used to describe a lot of other things elsewhere. Configuration specifically refers to the global kernel config.

## Structure
The configuration contains a number of slots. Each slot is identified by a key, which is a simple a **case-sensitive** string. It's made case sensitive to avoid converting ingoing/outgoing strings between cases, but best practice is to stick a single naming scheme. We recommend snake_case for keys.

A slot has some data associated with it, and a type identifying how the data should be interpreted. The types are fairly standard: bool, uint, and string. More complex operations can simply be represented as a string, and must be parsed at the consumer end. This keeps the configuration nice and simple.

The whole thing is very similar to a key/value store, with some type info.

## Locking
By default all slots are unlocked, but at any point they be switched to the locked state. When locked that slot becomes read-only. This prevents a critical setting being overriden by a batch-load of config options later on.

Since locking a slot means you're rejecting future changes, this means you may also loose more appropriate settings, so locking is best used with care.

## Initialization Order
The global config gathers input from several places early in the kernel initialization. The order is as follows:
- Default configuration slots are loaded. These are values built in to the Configuration.cpp file.
- Kernel command line is parsed.
- After the initdisk filesystem is mounted, the file `config/kernel.cfg` is parsed.

### Default Configuration Values
These are either hard-coded in `Configuration.cpp`, but most of them come from a file generated by the build system. It's *everytime* the kernel is rebuilt, even if nothing has changed. 

The file is created as part of the `$(CONFIG_HEADER_TARGET)` rule, which is near the bottom of the file (it's at the very bottom at the time of writing).

This file is generated by a series of echo commands appending lines to the file like `echo "#define NP_KCONFIG_SOME_VALUE 0x1234" >> $(CONFIG_HEADER_TARGET`, which each add a define to the file. Regenerating this file every build means that Configuriation.cpp must also be rebuilt everytime, in order to use the latest defines, fortunately there's not a lot of code here so it's normally quite quick.

## String Parsing and Formatting
Slot names are copied around verbatim, so they have very few naming restrictons. They cannot contain whitespace (in this context space or newline) as that indicates the end of the slot, and they cannot end with an exclamation mark (this is a reserved identifier, see below for why).

Configuration slots default to bool type, with a value of true. Meaning that if a value is declared as `example_option`, and later queried, it will return true. The value stored in the slot can be specified after an equals sign: `example_option=false` would create the same name and type as before, but with the value false. Slot parsing will try to resolve the types in the following order, trying the next if unsuccessful: bool -> uint -> string.

Bool values default to true, and accept common aliases like yes/no for values.

Uint values default to 0, and assume base 10 by default, but base 8 can be specified by a leading 0, or base 16 by a leading 0x. Binary is also supported by a leading 0b. Uint values are stored internally as *32-bit* integers, as those are big enough to hold most things and it allows us to reduce the memory footprint of a config slot. If you really, really need to pass a full 64-bit value (say a fixed address), you'll need to use two slots, with some sort of base + offset setup.

String values simply copying what comes after the equals sign into the value. They are the catch-all type, and provide the most flexibility for storage. Of course, they require the consuming code to do the parsing itself.

A slot can be locked in-line by adding an exclamation mark (`!`) to the end, right before the whitespace. 
